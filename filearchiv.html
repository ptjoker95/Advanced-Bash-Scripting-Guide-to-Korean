<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<title>File and Archiving Commands</title>
<meta name="GENERATOR" content="Modular DocBook HTML Stylesheet Version 1.7">
<link rel="HOME" title="Advanced Bash-Scripting Guide" href="./index.html">
<link rel="UP" title="External Filters, Programs and Commands" href="./external.html">
<link rel="PREVIOUS" title="Text Processing Commands" href="./textproc.html">
<link rel="NEXT" title="Communications Commands" href="./communications.html">
</head>
<body class="SECT1" alink="#0000FF" bgcolor="#FFFFFF" link="#0000FF" text="#000000" vlink="#840084">
<div id="dic_bubble" class="selection_bubble fontSize13 noSelect" style="z-index: 9999; border: 1px solid rgb(74, 174, 222); visibility: hidden;">
</div>
<div class="NAVHEADER">
<table summary="Header navigation table" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody>
<tr>
<th colspan="3" align="center">Advanced Bash-Scripting Guide: </th>
</tr>
<tr>
<td align="left" valign="bottom" width="10%">
<a href="./textproc.html" accesskey="P">Prev</a>
</td>
<td align="center" valign="bottom" width="80%">Chapter 16. External Filters, Programs and Commands</td>
<td align="right" valign="bottom" width="10%">
<a href="./communications.html" accesskey="N">Next</a>
</td>
</tr>
</tbody>
</table>
<hr align="LEFT" width="100%">
</div>
<div class="SECT1">
<h1 class="SECT1">
<a name="FILEARCHIV">
</a>16.5. File and Archiving Commands</h1>
<p>
</p>
<div class="VARIABLELIST">
<p>
<b>
<a name="FAARCHIVING1">
</a>Archiving</b>
</p>
<dl>
<dt>
<a name="TARREF">
</a>
<b class="COMMAND">tar</b>
</dt>
<dd>
<p>The standard UNIX archiving utility.

	        <a name="AEN11885" href="#FTN.AEN11885">
<span class="footnote">[1]</span>
</a>

	      Originally a
	      <i class="WORDASWORD">Tape ARchiving</i> program, it has
	      developed into a general purpose package that can handle
	      all manner of archiving with all types of destination
	      devices, ranging from tape drives to regular files to even
	      <tt class="FILENAME">stdout</tt> (see <a href="./special-chars.html#EX58">Example 3-4</a>). GNU
	      <i class="FIRSTTERM">tar</i> has been patched to accept
	      various compression filters, for example: <b class="COMMAND">tar
	      czvf archive_name.tar.gz *</b>, which recursively
	      archives and <a href="./filearchiv.html#GZIPREF">gzips</a>
	      all files in a directory tree except <a href="./basic.html#DOTFILESREF">dotfiles</a> in the current
	      working directory (<a href="./internalvariables.html#PWDREF">$PWD</a>).

		<a name="AEN11896" href="#FTN.AEN11896">
<span class="footnote">[2]</span>
</a>
            </p>
<p>Some useful <b class="COMMAND">tar</b> options:  
	      </p>
<p>
</p>
<ol type="1">
<li>
<p>
<tt class="OPTION">-c</tt> create (a new
		  archive)</p>
</li>
<li>
<p>
<tt class="OPTION">-x</tt> extract (files from
		  existing archive)</p>
</li>
<li>
<p>
<tt class="OPTION">--delete</tt> delete (files
		  from existing archive)</p>
<div class="CAUTION">
<p>
</p>
<table class="CAUTION" border="0" width="90%">
<tbody>
<tr>
<td align="CENTER" valign="TOP" width="25">
<img src="filearchiv_files/caution.gif" alt="Caution" hspace="5">
</td>
<td align="LEFT" valign="TOP">
<p>This option will not work on magnetic tape
		  devices.</p>
</td>
</tr>
</tbody>
</table>
</div>
</li>
<li>
<p>
<tt class="OPTION">-r</tt> append (files to
		  existing archive)</p>
</li>
<li>
<p>
<tt class="OPTION">-A</tt> append
		  (<i class="FIRSTTERM">tar</i> files to
		  existing archive)</p>
</li>
<li>
<p>
<tt class="OPTION">-t</tt> list (contents of
                  existing archive)</p>
</li>
<li>
<p>
<tt class="OPTION">-u</tt> update archive</p>
</li>
<li>
<p>
<tt class="OPTION">-d</tt> compare archive with
		  specified filesystem</p>
</li>
<li>
<p>
<tt class="OPTION">--after-date</tt> only process
		  files with a date stamp <em>after</em>
		  specified date</p>
</li>
<li>
<p>
<tt class="OPTION">-z</tt> <a href="./filearchiv.html#GZIPREF">gzip</a> the archive</p>
<p>(compress or uncompress, depending on whether
		combined with the <tt class="OPTION">-c</tt> or
		<tt class="OPTION">-x</tt>) option</p>
</li>
<li>
<p>
<tt class="OPTION">-j</tt>
		  <a href="./filearchiv.html#BZIPREF">bzip2</a> the
		  archive</p>
</li>
</ol>
	      <p>
</p>
<div class="CAUTION">
<p>
</p>
<table class="CAUTION" border="0" width="90%">
<tbody>
<tr>
<td align="CENTER" valign="TOP" width="25">
<img src="filearchiv_files/caution.gif" alt="Caution" hspace="5">
</td>
<td align="LEFT" valign="TOP">
<p>It may be difficult to recover data from a
	      corrupted <i class="FIRSTTERM">gzipped</i> tar
	      archive. When archiving important files, make multiple
	      backups.</p>
</td>
</tr>
</tbody>
</table>
</div>
</dd>
<dt>
<a name="SHARREF">
</a>
<b class="COMMAND">shar</b>
</dt>
<dd>
<p>
<i class="FIRSTTERM">Shell archiving</i> utility.
              The text and/or binary files in a shell archive are
              concatenated without compression, and the resultant
              archive is essentially a shell script, complete with
              <span class="TOKEN">#!/bin/sh</span> header, containing all the
              necessary unarchiving commands, as well as the files
              themselves. Unprintable binary characters in the target
              file(s) are converted to printable ASCII characters in the
              output <i class="FIRSTTERM">shar</i> file. <i class="FIRSTTERM">Shar
              archives</i> still show up in Usenet newsgroups,
              but otherwise <b class="COMMAND">shar</b> has been replaced
              by <b class="COMMAND">tar</b>/<b class="COMMAND">gzip</b>.
              The <b class="COMMAND">unshar</b> command unpacks
              <i class="FIRSTTERM">shar</i> archives.</p>
<p>The
              <b class="COMMAND">mailshar</b> command is a Bash script that
              uses <b class="COMMAND">shar</b> to concatenate multiple files
              into a single one for e-mailing.
              This script supports compression and <a href="./filearchiv.html#UUENCODEREF">uuencoding</a>.</p>
</dd>
<dt>
<a name="ARREF">
</a>
<b class="COMMAND">ar</b>
</dt>
<dd>
<p>아카이브를 만들고 조작함, 주로 바이너리 오브젝트 파일 라이브러리를 만드는 데 쓰임.</p>
</dd>
<dt>
<a name="RPMREF">
</a>
<b class="COMMAND">rpm</b>
</dt>
<dd>
<p>The <i class="FIRSTTERM">Red Hat Package Manager</i>, or
	      <b class="COMMAND">rpm</b> utility provides a wrapper for
	      source or binary archives. It includes commands for
	      installing and checking the integrity of packages, among
	      other things.</p>
<p>A simple <b class="COMMAND">rpm -i package_name.rpm</b>
	      usually suffices to install a package, though there are many
	      more options available.</p>
<div class="TIP">
<p>
</p>
<table class="TIP" border="0" width="90%">
<tbody>
<tr>
<td align="CENTER" valign="TOP" width="25">
<img src="filearchiv_files/tip.gif" alt="Tip" hspace="5">
</td>
<td align="LEFT" valign="TOP">
<p>
<tt class="USERINPUT">
<b>rpm -qf</b>
</tt> identifies which package a
	      file originates from.</p>
<p>	      <table bgcolor="#E0E0E0" border="1" width="90%">
<tbody>
<tr>
<td>
<font color="#000000">
<pre class="SCREEN">
<tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>rpm -qf /bin/ls</b></tt>
<tt class="COMPUTEROUTPUT">coreutils-5.2.1-31</tt></pre>
</font>
</td>
</tr>
</tbody>
</table>
	    </p>
</td>
</tr>
</tbody>
</table>
</div>
<div class="TIP">
<p>
</p>
<table class="TIP" border="0" width="90%">
<tbody>
<tr>
<td align="CENTER" valign="TOP" width="25">
<img src="filearchiv_files/tip.gif" alt="Tip" hspace="5">
</td>
<td align="LEFT" valign="TOP">
<p>
<tt class="USERINPUT">
<b>rpm -qa</b>
</tt> gives a
	      complete list of all installed <i class="FIRSTTERM">rpm</i> packages
	      on a given system. An <tt class="USERINPUT">
<b>rpm -qa package_name</b>
</tt>
	      lists only the package(s) corresponding to
	      <tt class="FILENAME">package_name</tt>.</p>
<p>	      <table bgcolor="#E0E0E0" border="1" width="90%">
<tbody>
<tr>
<td>
<font color="#000000">
<pre class="SCREEN">
<tt class="PROMPT">bash$ </tt>
<tt class="USERINPUT">
<b>rpm -qa</b>
</tt>
<tt class="COMPUTEROUTPUT">redhat-logos-1.1.3-1
 glibc-2.2.4-13
 cracklib-2.7-12
 dosfstools-2.7-1
 gdbm-1.8.0-10
 ksymoops-2.4.1-1
 mktemp-1.5-11
 perl-5.6.0-17
 reiserfs-utils-3.x.0j-2
 ...</tt>


<tt class="PROMPT">bash$ </tt>
<tt class="USERINPUT">
<b>rpm -qa docbook-utils</b>
</tt>
<tt class="COMPUTEROUTPUT">docbook-utils-0.6.9-2</tt>


<tt class="PROMPT">bash$ </tt>
<tt class="USERINPUT">
<b>rpm -qa docbook | grep docbook</b>
</tt>
<tt class="COMPUTEROUTPUT">docbook-dtd31-sgml-1.0-10
 docbook-style-dsssl-1.64-3
 docbook-dtd30-sgml-1.0-10
 docbook-dtd40-sgml-1.0-11
 docbook-utils-pdf-0.6.9-2
 docbook-dtd41-sgml-1.0-10
 docbook-utils-0.6.9-2</tt>
	      </pre>
</font>
</td>
</tr>
</tbody>
</table>
	    </p>
</td>
</tr>
</tbody>
</table>
</div>
</dd>
<dt>
<a name="CPIOREF">
</a>
<b class="COMMAND">cpio</b>
</dt>
<dd>
<p>이 특별한 아카이브 복사 명령어 (
<b class="COMMAND">c
</b>o
<b class="COMMAND">p
</b>y
<b class="COMMAND">i
</b>nput and 
<b class="COMMAND">o
</b>utput) 은 
<b class="COMMAND">tar
</b>/
<b class="COMMAND">gzip
</b> 으로 대체되어 더 이상은 보기 힘듭니다. 이 명령어는 디렉토리 전체를 옮길 때, 
아직 사용됩니다. (복사를 위한) 적당한 블럭 크기가 지정되면 
<b class="COMMAND">tar</b> 보다 상당히 빠릅니다.</p>
<div class="EXAMPLE">
<a name="EX48">
</a>
<p>
<b>예제 16-30. 
<i class="FIRSTTERM">cpio</i> 를 이용해서 디렉토리를 옮기기</b>
</p>
<table bgcolor="#E0E0E0" border="0" width="90%">
<tbody>
<tr>
<td>
<font color="#000000">
<pre class="PROGRAMLISTING">#!/bin/bash

# Copying a directory tree using cpio.

# Advantages of using 'cpio':
#   Speed of copying. It's faster than 'tar' with pipes.
#   Well suited for copying special files (named pipes, etc.)
#+  that 'cp' may choke on.

ARGS=2
E_BADARGS=65

if [ $# -ne "$ARGS" ]
then
  echo "Usage: `basename $0` source destination"
  exit $E_BADARGS
fi  

source="$1"
destination="$2"

###################################################################
find "$source" -depth | cpio -admvp "$destination"
#               ^^^^^         ^^^^^
#  Read the 'find' and 'cpio' info pages to decipher these options.
#  The above works only relative to $PWD (current directory) . . .
#+ full pathnames are specified.
###################################################################


# Exercise:
# --------

#  Add code to check the exit status ($?) of the 'find | cpio' pipe
#+ and output appropriate error messages if anything went wrong.

exit $?</pre>
</font>
</td>
</tr>
</tbody>
</table>
</div>
</dd>
<dt>
<a name="RPM2CPIOREF">
</a>
<b class="COMMAND">rpm2cpio</b>
</dt>
<dd>
<p>This command extracts a
	      <b class="COMMAND">cpio</b> archive from an <a href="./filearchiv.html#RPMREF">rpm</a> one.</p>
<div class="EXAMPLE">
<a name="DERPM">
</a>
<p>
<b>Example 16-31. Unpacking an <i class="FIRSTTERM">rpm</i> archive</b>
</p>
<table bgcolor="#E0E0E0" border="0" width="90%">
<tbody>
<tr>
<td>
<font color="#000000">
<pre class="PROGRAMLISTING">#!/bin/bash
# de-rpm.sh: Unpack an 'rpm' archive

: ${1?"Usage: `basename $0` target-file"}
# Must specify 'rpm' archive name as an argument.


TEMPFILE=$$.cpio                         #  Tempfile with "unique" name.
                                         #  $$ is process ID of script.

rpm2cpio &lt; $1 &gt; $TEMPFILE                #  Converts rpm archive into
                                         #+ cpio archive.
cpio --make-directories -F $TEMPFILE -i  #  Unpacks cpio archive.
rm -f $TEMPFILE                          #  Deletes cpio archive.

exit 0

#  Exercise:
#  Add check for whether 1) "target-file" exists and
#+                       2) it is an rpm archive.
#  Hint:                    Parse output of 'file' command.</pre>
</font>
</td>
</tr>
</tbody>
</table>
</div>
</dd>
<dt>
<a name="PAXREF">
</a>
<b class="COMMAND">pax</b>
</dt>
<dd>
<p>The <i class="FIRSTTERM">pax</i>
            <b class="COMMAND">p</b>ortable <b class="COMMAND">a</b>rchive
            e<b class="COMMAND">x</b>change toolkit facilitates periodic
            file backups and is designed to be cross-compatible
            between various flavors of UNIX. It was designed
	    to replace <a href="./filearchiv.html#TARREF">tar</a> and <a href="./filearchiv.html#CPIOREF">cpio</a>.</p>
<p>	  <table bgcolor="#E0E0E0" border="0" width="90%">
<tbody>
<tr>
<td>
<font color="#000000">
<pre class="PROGRAMLISTING">pax -wf daily_backup.pax ~/linux-server/files 
#  Creates a tar archive of all files in the target directory.
#  Note that the options to pax must be in the correct order --
#+ pax -fw     has an entirely different effect.

pax -f daily_backup.pax
#  Lists the files in the archive.

pax -rf daily_backup.pax ~/bsd-server/files
#  Restores the backed-up files from the Linux machine
#+ onto a BSD one.</pre>
</font>
</td>
</tr>
</tbody>
</table>
	  </p>
<p>Note that <i class="FIRSTTERM">pax</i> handles many of
            the standard archiving and compression commands.</p>
</dd>
</dl>
</div>
<p>
</p>
<div class="VARIABLELIST">
<p>
<b>
<a name="FACOMPRESSION1">
</a>Compression</b>
</p>
<dl>
<dt>
<a name="GZIPREF">
</a>
<b class="COMMAND">gzip</b>
</dt>
<dd>
<p>The standard GNU/UNIX compression utility, replacing
	      the inferior and proprietary
	      <b class="COMMAND">compress</b>. The corresponding decompression
	      command is <b class="COMMAND">gunzip</b>, which is the equivalent of
	      <b class="COMMAND">gzip -d</b>.</p>
<div class="NOTE">
<p>
</p>
<table class="NOTE" border="0" width="90%">
<tbody>
<tr>
<td align="CENTER" valign="TOP" width="25">
<img src="filearchiv_files/note.gif" alt="Note" hspace="5">
</td>
<td align="LEFT" valign="TOP">
<p>The <tt class="OPTION">-c</tt> option sends the output of
	      <b class="COMMAND">gzip</b> to <tt class="FILENAME">stdout</tt>. This
	      is useful when <a href="./special-chars.html#PIPEREF">piping</a> to other
	      commands.</p>
</td>
</tr>
</tbody>
</table>
</div>
<p>
<a name="ZCATREF">
</a>
</p>
<p>The <b class="COMMAND">zcat</b> filter decompresses a
	      <i class="FIRSTTERM">gzipped</i> file to
	      <tt class="FILENAME">stdout</tt>, as possible input to a pipe or
	      redirection. This is, in effect, a <b class="COMMAND">cat</b>
	      command that works on compressed files (including files
	      processed with the older <a href="./filearchiv.html#COMPRESSREF">compress</a>
	      utility). The <b class="COMMAND">zcat</b> command is equivalent to
	      <b class="COMMAND">gzip -dc</b>.</p>
<div class="CAUTION">
<p>
</p>
<table class="CAUTION" border="0" width="90%">
<tbody>
<tr>
<td align="CENTER" valign="TOP" width="25">
<img src="filearchiv_files/caution.gif" alt="Caution" hspace="5">
</td>
<td align="LEFT" valign="TOP">
<p>On some commercial UNIX systems, <b class="COMMAND">zcat</b>
	      is a synonym for <b class="COMMAND">uncompress -c</b>,
	      and will not work on <i class="FIRSTTERM">gzipped</i>
	      files.</p>
</td>
</tr>
</tbody>
</table>
</div>
<p>See also <a href="./comparison-ops.html#EX14">Example 7-7</a>.</p>
</dd>
<dt>
<a name="BZIPREF">
</a>
<b class="COMMAND">bzip2</b>
</dt>
<dd>
<p>또다른 방식의 압축 유틸리티, 특별히 큰 파일에 대해, 
<b class="COMMAND">gzip</b> 보다 효율적 (하지만 느림) 입니다. 이 압축에 대한 해제 명령어는 
<b class="COMMAND">bunzip2</b> 입니다.
</p>
<p>
<b class="COMMAND">zcat</b> 명령어와 유사하게, 
<b class="COMMAND">bzcat</b> 는 <i class="FIRSTTERM">bzipped2 로 압축된</i> 파일을 
해제해 
<tt class="FILENAME">stdout</tt> 로 출력합니다.
</p>
<div class="NOTE">
<p>
</p>
<table class="NOTE" border="0" width="90%">
<tbody>
<tr>
<td align="CENTER" valign="TOP" width="25">
<img src="filearchiv_files/note.gif" alt="Note" hspace="5">
</td>
<td align="LEFT" valign="TOP">
<p>
<a href="./filearchiv.html#TARREF">tar</a> 새 버전에서는 
<b class="COMMAND">bzip2</b> 을 지원하도록 패치되었습니다.</p>
</td>
</tr>
</tbody>
</table>
</div>
</dd>
<dt>
<a name="COMPRESSREF">
</a>
<b class="COMMAND">compress</b>, <a name="UNCOMPRESSREF">
</a>
<b class="COMMAND">uncompress</b>
</dt>
<dd>
<p>이 명령어는 상업적인 UNIX 배포판에서 있는 오래되고, 독점적인 압축 
유틸리티입니다. 현재로선 더 효율적인 
<b class="COMMAND">gzip</b> 이 대체하고 있습니다. 리눅스 배포판에는 호환을 위해 
<b class="COMMAND">compress</b> 을 포함하고 있지만, 
<b class="COMMAND">gunzip</b> 으로도 
<b class="COMMAND">compress</b> 로 압축된 파일을 압축해제할 수 있습니다.</p>
<div class="TIP">
<p>
</p>
<table class="TIP" border="0" width="90%">
<tbody>
<tr>
<td align="CENTER" valign="TOP" width="25">
<img src="filearchiv_files/tip.gif" alt="Tip" hspace="5">
</td>
<td align="LEFT" valign="TOP">
<p>
<b class="COMMAND">znew</b> 명령어는 
<i class="FIRSTTERM">compress</i> 로 압축된 파일을 
<i class="FIRSTTERM">gzipped</i> 으로 바꿔줍니다.</p>
</td>
</tr>
</tbody>
</table>
</div>
</dd>
<dt>
<a name="SQREF">
</a>
<b class="COMMAND">sq</b>
</dt>
<dd>
<p>Yet another compression (<b class="COMMAND">sq</b>ueeze)
	      utility, a filter that works only on sorted
	      <a href="./special-chars.html#ASCIIDEF">ASCII</a> word lists. It
	      uses the standard invocation syntax for a filter,
	      <b class="COMMAND">sq &lt; input-file &gt; output-file</b>.
	      Fast, but not nearly as efficient as <a href="./filearchiv.html#GZIPREF">gzip</a>.  The corresponding
	      uncompression filter is <b class="COMMAND">unsq</b>, invoked
	      like <b class="COMMAND">sq</b>.</p>
<div class="TIP">
<p>
</p>
<table class="TIP" border="0" width="90%">
<tbody>
<tr>
<td align="CENTER" valign="TOP" width="25">
<img src="filearchiv_files/tip.gif" alt="Tip" hspace="5">
</td>
<td align="LEFT" valign="TOP">
<p>The output of <b class="COMMAND">sq</b> may be
	        piped to <b class="COMMAND">gzip</b> for further
		compression.</p>
</td>
</tr>
</tbody>
</table>
</div>
</dd>
<dt>
<a name="ZIPREF">
</a>
<b class="COMMAND">zip</b>, <b class="COMMAND">unzip</b>
</dt>
<dd>
<p>Cross-platform file archiving and compression utility
	      compatible with DOS <i class="FIRSTTERM">pkzip.exe</i>.
	      <span class="QUOTE">"Zipped"</span> archives seem to be a more
	      common medium of file exchange on the Internet than
	      <span class="QUOTE">"tarballs."</span>
</p>
</dd>
<dt>
<a name="UNARCREF">
</a>
<b class="COMMAND">unarc</b>, <b class="COMMAND">unarj</b>, <b class="COMMAND">unrar</b>
</dt>
<dd>
<p>These Linux utilities permit unpacking archives
	      compressed with the DOS <i class="FIRSTTERM">arc.exe</i>,
	      <i class="FIRSTTERM">arj.exe</i>, and
	      <i class="FIRSTTERM">rar.exe</i> programs.</p>
</dd>
<dt>
<a name="LZMAREF">
</a>
<b class="COMMAND">lzma</b>, <b class="COMMAND">unlzma</b>, <b class="COMMAND">lzcat</b>
</dt>
<dd>
<p>Highly efficient Lempel-Ziv-Markov compression.
	      The syntax of <i class="FIRSTTERM">lzma</i> is similar to
              that of <i class="FIRSTTERM">gzip</i>. The <a href="http://www.7-zip.org/sdk.html" target="_top">7-zip Website</a>
              has more information.</p>
</dd>
<dt>
<a name="XZREF">
</a>
<b class="COMMAND">xz</b>, <b class="COMMAND">unxz</b>, <b class="COMMAND">xzcat</b>
</dt>
<dd>
<p>A new high-efficiency compression tool, backward compatible
	      with <i class="FIRSTTERM">lzma</i>, and with an invocation
	      syntax similar to <i class="FIRSTTERM">gzip</i>. For
	      more information, see the <a href="http://en.wikipedia.org/wiki/Xz" target="_top">Wikipedia
	      entry</a>.</p>
</dd>
</dl>
</div>
<p>
</p>
<div class="VARIABLELIST">
<p>
<b>
<a name="FAINFORMATION1">
</a>File Information</b>
</p>
<dl>
<dt>
<a name="FILEREF">
</a>
<b class="COMMAND">file</b>
</dt>
<dd>
<p>A utility for identifying file types. The command
	      <tt class="USERINPUT">
<b>file file-name</b>
</tt> will return a
	      file specification for <tt class="FILENAME">file-name</tt>,
	      such as <tt class="COMPUTEROUTPUT">ascii text</tt> or
	      <tt class="COMPUTEROUTPUT">data</tt>. It references
	      the <a href="./sha-bang.html#MAGNUMREF">magic numbers</a>
	      found in <tt class="FILENAME">/usr/share/magic</tt>,
	      <tt class="FILENAME">/etc/magic</tt>, or
	      <tt class="FILENAME">/usr/lib/magic</tt>, depending on the
	      Linux/UNIX distribution.</p>
<p>The <tt class="OPTION">-f</tt> option causes
	      <b class="COMMAND">file</b> to run in <a href="./timedate.html#BATCHPROCREF">batch</a> mode, to read from
	      a designated file a list of filenames to analyze. The
	      <tt class="OPTION">-z</tt> option, when used on a compressed
	      target file, forces an attempt to analyze the uncompressed
	      file type.</p>
<p>	      <table bgcolor="#E0E0E0" border="1" width="90%">
<tbody>
<tr>
<td>
<font color="#000000">
<pre class="SCREEN">
<tt class="PROMPT">bash$ </tt>
<tt class="USERINPUT">
<b>file test.tar.gz</b>
</tt>
<tt class="COMPUTEROUTPUT">test.tar.gz: gzip compressed data, deflated,
 last modified: Sun Sep 16 13:34:51 2001, os: Unix</tt>

<tt class="PROMPT">bash </tt>
<tt class="USERINPUT">
<b>file -z test.tar.gz</b>
</tt>
<tt class="COMPUTEROUTPUT">test.tar.gz: GNU tar archive (gzip compressed data, deflated,
 last modified: Sun Sep 16 13:34:51 2001, os: Unix)</tt>
	      </pre>
</font>
</td>
</tr>
</tbody>
</table>
	    </p>
<p>	      <table bgcolor="#E0E0E0" border="0" width="90%">
<tbody>
<tr>
<td>
<font color="#000000">
<pre class="PROGRAMLISTING"># Find sh and Bash scripts in a given directory:

DIRECTORY=/usr/local/bin
KEYWORD=Bourne
# Bourne and Bourne-Again shell scripts

file $DIRECTORY/* | fgrep $KEYWORD

# Output:

# /usr/local/bin/burn-cd:          Bourne-Again shell script text executable
# /usr/local/bin/burnit:           Bourne-Again shell script text executable
# /usr/local/bin/cassette.sh:      Bourne shell script text executable
# /usr/local/bin/copy-cd:          Bourne-Again shell script text executable
# . . .</pre>
</font>
</td>
</tr>
</tbody>
</table>
	    </p>
<div class="EXAMPLE">
<a name="STRIPC">
</a>
<p>
<b>Example 16-32. Stripping comments from C program files</b>
</p>
<table bgcolor="#E0E0E0" border="0" width="90%">
<tbody>
<tr>
<td>
<font color="#000000">
<pre class="PROGRAMLISTING">#!/bin/bash
# strip-comment.sh: Strips out the comments (/* COMMENT */) in a C program.

E_NOARGS=0
E_ARGERROR=66
E_WRONG_FILE_TYPE=67

if [ $# -eq "$E_NOARGS" ]
then
  echo "Usage: `basename $0` C-program-file" &gt;&amp;2 # Error message to stderr.
  exit $E_ARGERROR
fi  

# Test for correct file type.
type=`file $1 | awk '{ print $2, $3, $4, $5 }'`
# "file $1" echoes file type . . .
# Then awk removes the first field, the filename . . .
# Then the result is fed into the variable "type."
correct_type="ASCII C program text"

if [ "$type" != "$correct_type" ]
then
  echo
  echo "This script works on C program files only."
  echo
  exit $E_WRONG_FILE_TYPE
fi  


# Rather cryptic sed script:
#--------
sed '
/^\/\*/d
/.*\*\//d
' $1
#--------
# Easy to understand if you take several hours to learn sed fundamentals.


#  Need to add one more line to the sed script to deal with
#+ case where line of code has a comment following it on same line.
#  This is left as a non-trivial exercise.

#  Also, the above code deletes non-comment lines with a "*/" . . .
#+ not a desirable result.

exit 0


# ----------------------------------------------------------------
# Code below this line will not execute because of 'exit 0' above.

# Stephane Chazelas suggests the following alternative:

usage() {
  echo "Usage: `basename $0` C-program-file" &gt;&amp;2
  exit 1
}

WEIRD=`echo -n -e '\377'`   # or WEIRD=$'\377'
[[ $# -eq 1 ]] || usage
case `file "$1"` in
  *"C program text"*) sed -e "s%/\*%${WEIRD}%g;s%\*/%${WEIRD}%g" "$1" \
     | tr '\377\n' '\n\377' \
     | sed -ne 'p;n' \
     | tr -d '\n' | tr '\377' '\n';;
  *) usage;;
esac

#  This is still fooled by things like:
#  printf("/*");
#  or
#  /*  /* buggy embedded comment */
#
#  To handle all special cases (comments in strings, comments in string
#+ where there is a \", \\" ...),
#+ the only way is to write a C parser (using lex or yacc perhaps?).

exit 0</pre>
</font>
</td>
</tr>
</tbody>
</table>
</div>
</dd>
<dt>
<a name="WHICHREF">
</a>
<b class="COMMAND">which</b>
</dt>
<dd>
<p>
<b class="COMMAND">which command</b> gives the full path
	      to <span class="QUOTE">"command."</span> This is useful for finding
	      out whether a particular command or utility is installed
	      on the system.</p>
<p>
<tt class="USERINPUT">
<b>$bash which rm</b>
</tt>
<table bgcolor="#E0E0E0" border="1" width="90%">
<tbody>
<tr>
<td>
<font color="#000000">
<pre class="SCREEN">
<tt class="COMPUTEROUTPUT">/usr/bin/rm</tt>
</pre>
</font>
</td>
</tr>
</tbody>
</table>
	  </p>
<p>For an interesting use of this command, see <a href="./colorizing.html#HORSERACE">Example 36-16</a>.</p>
</dd>
<dt>
<a name="WHEREISREF">
</a>
<b class="COMMAND">whereis</b>
</dt>
<dd>
<p>Similar to <b class="COMMAND">which</b>, above,
	      <b class="COMMAND">whereis command</b> gives the
	      full path to <span class="QUOTE">"command,"</span> but also to its
	      <a href="./basic.html#MANREF">manpage</a>.</p>
<p>
<tt class="USERINPUT">
<b>$bash whereis rm</b>
</tt>
<table bgcolor="#E0E0E0" border="1" width="90%">
<tbody>
<tr>
<td>
<font color="#000000">
<pre class="SCREEN">
<tt class="COMPUTEROUTPUT">rm: /bin/rm /usr/share/man/man1/rm.1.bz2</tt>
</pre>
</font>
</td>
</tr>
</tbody>
</table>
	  </p>
</dd>
<dt>
<a name="WHATISREF">
</a>
<b class="COMMAND">whatis</b>
</dt>
<dd>
<p>
<b class="COMMAND">whatis command</b> looks up
	      <span class="QUOTE">"command"</span> in the
	      <tt class="REPLACEABLE">
<i>whatis</i>
</tt> database. This is useful
	      for identifying system commands and important configuration
	      files. Consider it a simplified <b class="COMMAND">man</b>
	      command.</p>
<p>
<tt class="USERINPUT">
<b>$bash whatis whatis</b>
</tt>
<table bgcolor="#E0E0E0" border="1" width="90%">
<tbody>
<tr>
<td>
<font color="#000000">
<pre class="SCREEN">
<tt class="COMPUTEROUTPUT">whatis               (1)  - search the whatis database for complete words</tt>
</pre>
</font>
</td>
</tr>
</tbody>
</table>
	  </p>
<div class="EXAMPLE">
<a name="WHAT">
</a>
<p>
<b>Example 16-33. Exploring <tt class="FILENAME">/usr/X11R6/bin</tt>
</b>
</p>
<table bgcolor="#E0E0E0" border="0" width="90%">
<tbody>
<tr>
<td>
<font color="#000000">
<pre class="PROGRAMLISTING">#!/bin/bash

# What are all those mysterious binaries in /usr/X11R6/bin?

DIRECTORY="/usr/X11R6/bin"
# Try also "/bin", "/usr/bin", "/usr/local/bin", etc.

for file in $DIRECTORY/*
do
  whatis `basename $file`   # Echoes info about the binary.
done

exit 0

#  Note: For this to work, you must create a "whatis" database
#+ with /usr/sbin/makewhatis.
#  You may wish to redirect output of this script, like so:
#    ./what.sh &gt;&gt;whatis.db
#  or view it a page at a time on stdout,
#    ./what.sh | less</pre>
</font>
</td>
</tr>
</tbody>
</table>
</div>
<p>See also <a href="./loops1.html#FILEINFO">Example 11-3</a>.</p>
</dd>
<dt>
<a name="VDIRREF">
</a>
<b class="COMMAND">vdir</b>
</dt>
<dd>
<p>Show a detailed directory listing. The effect is similar to
	      <a href="./basic.html#LSREF">ls -lb</a>.</p>
<p>This is one of the GNU
	    <i class="FIRSTTERM">fileutils</i>.</p>
<p>	      <table bgcolor="#E0E0E0" border="1" width="90%">
<tbody>
<tr>
<td>
<font color="#000000">
<pre class="SCREEN">
<tt class="PROMPT">bash$ </tt>
<tt class="USERINPUT">
<b>vdir</b>
</tt>
<tt class="COMPUTEROUTPUT">total 10
 -rw-r--r--    1 bozo  bozo      4034 Jul 18 22:04 data1.xrolo
 -rw-r--r--    1 bozo  bozo      4602 May 25 13:58 data1.xrolo.bak
 -rw-r--r--    1 bozo  bozo       877 Dec 17  2000 employment.xrolo</tt>

<tt class="PROMPT">bash </tt>
<tt class="USERINPUT">
<b>ls -l</b>
</tt>
<tt class="COMPUTEROUTPUT">total 10
 -rw-r--r--    1 bozo  bozo      4034 Jul 18 22:04 data1.xrolo
 -rw-r--r--    1 bozo  bozo      4602 May 25 13:58 data1.xrolo.bak
 -rw-r--r--    1 bozo  bozo       877 Dec 17  2000 employment.xrolo</tt>
	      </pre>
</font>
</td>
</tr>
</tbody>
</table>
	      </p>
</dd>
<dt>
<a name="LOCATEREF">
</a>
<b class="COMMAND">locate</b>, <a name="SLOCATEREF">
</a>
<b class="COMMAND">slocate</b>
</dt>
<dd>
<p>The <b class="COMMAND">locate</b> command searches for
	      files using a database stored for just that purpose. The
	      <b class="COMMAND">slocate</b> command is the secure version of
	      <b class="COMMAND">locate</b> (which may be aliased to
	      <b class="COMMAND">slocate</b>).</p>
<p>
<tt class="USERINPUT">
<b>$bash locate hickson</b>
</tt>
<table bgcolor="#E0E0E0" border="1" width="90%">
<tbody>
<tr>
<td>
<font color="#000000">
<pre class="SCREEN">
<tt class="COMPUTEROUTPUT">/usr/lib/xephem/catalogs/hickson.edb</tt>
</pre>
</font>
</td>
</tr>
</tbody>
</table>
</p>
</dd>
<dt>
<a name="GETFACLREF">
</a>
<b class="COMMAND">getfacl</b>, <a name="SETFACLREF">
</a>
<b class="COMMAND">setfacl</b>
</dt>
<dd>
<p>These commands <i class="FIRSTTERM">retrieve</i> or
              <i class="FIRSTTERM">set</i> the <b class="COMMAND">f</b>ile
              <b class="COMMAND">a</b>ccess <b class="COMMAND">c</b>ontrol
              <b class="COMMAND">l</b>ist -- the <i class="FIRSTTERM">owner</i>,
	      <i class="FIRSTTERM">group</i>, and file permissions.</p>
<p>	      <table bgcolor="#E0E0E0" border="1" width="90%">
<tbody>
<tr>
<td>
<font color="#000000">
<pre class="SCREEN">
<tt class="PROMPT">bash$ </tt>
<tt class="USERINPUT">
<b>getfacl *</b>
</tt>
<tt class="COMPUTEROUTPUT"># file: test1.txt
 # owner: bozo
 # group: bozgrp
 user::rw-
 group::rw-
 other::r--

 # file: test2.txt
 # owner: bozo
 # group: bozgrp
 user::rw-
 group::rw-
 other::r--</tt>
 

 
<tt class="PROMPT">bash$ </tt>
<tt class="USERINPUT">
<b>setfacl -m u:bozo:rw yearly_budget.csv</b>
</tt>
<tt class="PROMPT">bash$ </tt>
<tt class="USERINPUT">
<b>getfacl yearly_budget.csv</b>
</tt>
<tt class="COMPUTEROUTPUT"># file: yearly_budget.csv
 # owner: accountant
 # group: budgetgrp
 user::rw-
 user:bozo:rw-
 user:accountant:rw-
 group::rw-
 mask::rw-
 other::r--</tt>
	      </pre>
</font>
</td>
</tr>
</tbody>
</table>
	    </p>
</dd>
<dt>
<a name="READLINKREF">
</a>
<b class="COMMAND">readlink</b>
</dt>
<dd>
<p>Disclose the file that a symbolic link points to.</p>
<p>	      <table bgcolor="#E0E0E0" border="1" width="90%">
<tbody>
<tr>
<td>
<font color="#000000">
<pre class="SCREEN">
<tt class="PROMPT">bash$ </tt>
<tt class="USERINPUT">
<b>readlink /usr/bin/awk</b>
</tt>
<tt class="COMPUTEROUTPUT">../../bin/gawk</tt>
	      </pre>
</font>
</td>
</tr>
</tbody>
</table>
	    </p>
</dd>
<dt>
<a name="STRINGSREF">
</a>
<b class="COMMAND">strings</b>
</dt>
<dd>
<p>Use the <b class="COMMAND">strings</b> command to find
	      printable strings in a binary or data file. It will list
	      sequences of printable characters found in the target
	      file. This might be handy for a quick 'n dirty examination
	      of a core dump or for looking at an unknown graphic image
	      file (<tt class="USERINPUT">
<b>strings image-file | more</b>
</tt> might
	      show something like <i class="FIRSTTERM">JFIF</i>,
	      which would identify the file as a <i class="FIRSTTERM">jpeg</i>
	      graphic). In a script, you would probably
	      parse the output of <b class="COMMAND">strings</b>
	      with <a href="./textproc.html#GREPREF">grep</a> or <a href="./sedawk.html#SEDREF">sed</a>. See <a href="./loops1.html#BINGREP">Example 11-8</a>
	      and <a href="./loops1.html#FINDSTRING">Example 11-10</a>.</p>
<div class="EXAMPLE">
<a name="WSTRINGS">
</a>
<p>
<b>Example 16-34. An <span class="QUOTE">"improved"</span>
	      <i class="FIRSTTERM">strings</i> command</b>
</p>
<table bgcolor="#E0E0E0" border="0" width="90%">
<tbody>
<tr>
<td>
<font color="#000000">
<pre class="PROGRAMLISTING">#!/bin/bash
# wstrings.sh: "word-strings" (enhanced "strings" command)
#
#  This script filters the output of "strings" by checking it
#+ against a standard word list file.
#  This effectively eliminates gibberish and noise,
#+ and outputs only recognized words.

# ===========================================================
#                 Standard Check for Script Argument(s)
ARGS=1
E_BADARGS=85
E_NOFILE=86

if [ $# -ne $ARGS ]
then
  echo "Usage: `basename $0` filename"
  exit $E_BADARGS
fi

if [ ! -f "$1" ]                      # Check if file exists.
then
    echo "File \"$1\" does not exist."
    exit $E_NOFILE
fi
# ===========================================================


MINSTRLEN=3                           #  Minimum string length.
WORDFILE=/usr/share/dict/linux.words  #  Dictionary file.
#  May specify a different word list file
#+ of one-word-per-line format.
#  For example, the "yawl" word-list package,
#  http://bash.deta.in/yawl-0.3.2.tar.gz


wlist=`strings "$1" | tr A-Z a-z | tr '[:space:]' Z | \
       tr -cs '[:alpha:]' Z | tr -s '\173-\377' Z | tr Z ' '`

# Translate output of 'strings' command with multiple passes of 'tr'.
#  "tr A-Z a-z"  converts to lowercase.
#  "tr '[:space:]'"  converts whitespace characters to Z's.
#  "tr -cs '[:alpha:]' Z"  converts non-alphabetic characters to Z's,
#+ and squeezes multiple consecutive Z's.
#  "tr -s '\173-\377' Z"  converts all characters past 'z' to Z's
#+ and squeezes multiple consecutive Z's,
#+ which gets rid of all the weird characters that the previous
#+ translation failed to deal with.
#  Finally, "tr Z ' '" converts all those Z's to whitespace,
#+ which will be seen as word separators in the loop below.

#  ***********************************************************************
#  Note the technique of feeding/piping the output of 'tr' back to itself,
#+ but with different arguments and/or options on each successive pass.
#  ***********************************************************************


for word in $wlist                    #  Important:
                                      #  $wlist must not be quoted here.
                                      # "$wlist" does not work.
                                      #  Why not?
do
  strlen=${#word}                     #  String length.
  if [ "$strlen" -lt "$MINSTRLEN" ]   #  Skip over short strings.
  then
    continue
  fi

  grep -Fw $word "$WORDFILE"          #   Match whole words only.
#      ^^^                            #  "Fixed strings" and
                                      #+ "whole words" options. 
done  

exit $?</pre>
</font>
</td>
</tr>
</tbody>
</table>
</div>
</dd>
</dl>
</div>
<p>
</p>
<div class="VARIABLELIST">
<p>
<b>
<a name="COMPARISONN1">
</a>Comparison</b>
</p>
<dl>
<dt>
<a name="DIFFREF">
</a>
<b class="COMMAND">diff</b>, <b class="COMMAND">patch</b>
</dt>
<dd>
<p>
<b class="COMMAND">diff</b>: flexible file comparison
	      utility. It compares the target files line-by-line
	      sequentially.  In some applications, such as comparing
	      word dictionaries, it may be helpful to filter the
	      files through <a href="./textproc.html#SORTREF">sort</a>
	      and <b class="COMMAND">uniq</b> before piping them
	      to <b class="COMMAND">diff</b>. <tt class="USERINPUT">
<b>diff file-1
	      file-2</b>
</tt> outputs the lines in the files that
	      differ, with carets showing which file each particular
	      line belongs to.</p>
<p>The <tt class="OPTION">--side-by-side</tt> option to
	    <b class="COMMAND">diff</b> outputs each compared file, line by
	    line, in separate columns, with non-matching lines marked. The
	    <tt class="OPTION">-c</tt> and <tt class="OPTION">-u</tt> options likewise
	    make the output of the command easier to interpret.</p>
<p>There are available various fancy frontends for
	    <b class="COMMAND">diff</b>, such as <b class="COMMAND">sdiff</b>,
	    <b class="COMMAND">wdiff</b>, <b class="COMMAND">xdiff</b>, and
	    <b class="COMMAND">mgdiff</b>. </p>
<div class="TIP">
<p>
</p>
<table class="TIP" border="0" width="90%">
<tbody>
<tr>
<td align="CENTER" valign="TOP" width="25">
<img src="filearchiv_files/tip.gif" alt="Tip" hspace="5">
</td>
<td align="LEFT" valign="TOP">
<p>
<a name="DIFFERR2">
</a>The <b class="COMMAND">diff</b>
              command returns an exit status of <span class="ERRORCODE">0</span>
              if the compared files are identical, and
              <span class="ERRORCODE">1</span> if they differ (or
              <span class="ERRORCODE">2</span> when <i class="FIRSTTERM">binary</i>
              files are being compared).  This permits use of
              <b class="COMMAND">diff</b> in a test construct within a shell
              script (see below).</p>
</td>
</tr>
</tbody>
</table>
</div>
<p>A common use for <b class="COMMAND">diff</b> is generating
	      difference files to be used with <b class="COMMAND">patch</b>
	      The <tt class="OPTION">-e</tt> option outputs files suitable
	      for <b class="COMMAND">ed</b> or <b class="COMMAND">ex</b>
	      scripts.</p>
<p>
<a name="PATCHREF">
</a>
</p>
<p>
<b class="COMMAND">patch</b>: flexible versioning
	      utility. Given a difference file generated by
	      <b class="COMMAND">diff</b>, <b class="COMMAND">patch</b> can
	      upgrade a previous version of a package to a newer version.
	      It is much more convenient to distribute a relatively
	      small <span class="QUOTE">"diff"</span> file than the entire body of a
	      newly revised package. Kernel <span class="QUOTE">"patches"</span> have
	      become the preferred method of distributing the frequent
	      releases of the Linux kernel.</p>
<p>
<table bgcolor="#E0E0E0" border="0" width="90%">
<tbody>
<tr>
<td>
<font color="#000000">
<pre class="PROGRAMLISTING">patch -p1 &lt;patch-file
# Takes all the changes listed in 'patch-file'
# and applies them to the files referenced therein.
# This upgrades to a newer version of the package.</pre>
</font>
</td>
</tr>
</tbody>
</table>
</p>
<p>Patching the kernel:</p>
<p>
<table bgcolor="#E0E0E0" border="0" width="90%">
<tbody>
<tr>
<td>
<font color="#000000">
<pre class="PROGRAMLISTING">cd /usr/src
gzip -cd patchXX.gz | patch -p0
# Upgrading kernel source using 'patch'.
# From the Linux kernel docs "README",
# by anonymous author (Alan Cox?).</pre>
</font>
</td>
</tr>
</tbody>
</table>
</p>
<div class="NOTE">
<p>
</p>
<table class="NOTE" border="0" width="90%">
<tbody>
<tr>
<td align="CENTER" valign="TOP" width="25">
<img src="filearchiv_files/note.gif" alt="Note" hspace="5">
</td>
<td align="LEFT" valign="TOP">
<p>The <b class="COMMAND">diff</b> command can also
	      recursively compare directories (for the filenames
	      present).</p>
<p>	      <table bgcolor="#E0E0E0" border="1" width="90%">
<tbody>
<tr>
<td>
<font color="#000000">
<pre class="SCREEN">
<tt class="PROMPT">bash$ </tt>
<tt class="USERINPUT">
<b>diff -r ~/notes1 ~/notes2</b>
</tt>
<tt class="COMPUTEROUTPUT">Only in /home/bozo/notes1: file02
 Only in /home/bozo/notes1: file03
 Only in /home/bozo/notes2: file04</tt>
	      </pre>
</font>
</td>
</tr>
</tbody>
</table>
	    </p>
</td>
</tr>
</tbody>
</table>
</div>
<div class="TIP">
<p>
</p>
<table class="TIP" border="0" width="90%">
<tbody>
<tr>
<td align="CENTER" valign="TOP" width="25">
<img src="filearchiv_files/tip.gif" alt="Tip" hspace="5">
</td>
<td align="LEFT" valign="TOP">
<p>
<a name="ZDIFFREF">
</a>
</p>
<p>Use <b class="COMMAND">zdiff</b> to compare
	       <i class="FIRSTTERM">gzipped</i> files.</p>
</td>
</tr>
</tbody>
</table>
</div>
<div class="TIP">
<p>
</p>
<table class="TIP" border="0" width="90%">
<tbody>
<tr>
<td align="CENTER" valign="TOP" width="25">
<img src="filearchiv_files/tip.gif" alt="Tip" hspace="5">
</td>
<td align="LEFT" valign="TOP">
<p>
<a name="DIFFSTATREF">
</a>
</p>
<p>Use <b class="COMMAND">diffstat</b> to create
	       a histogram (point-distribution graph) of output from
	       <b class="COMMAND">diff</b>.</p>
</td>
</tr>
</tbody>
</table>
</div>
</dd>
<dt>
<a name="DIFF3REF">
</a>
<b class="COMMAND">diff3</b>, <b class="COMMAND">merge</b>
</dt>
<dd>
<p>An extended version of <b class="COMMAND">diff</b> that compares
	      three files at a time. This command returns an exit value
	      of 0 upon successful execution, but unfortunately this gives
	      no information about the results of the comparison.</p>
<p>	      <table bgcolor="#E0E0E0" border="1" width="90%">
<tbody>
<tr>
<td>
<font color="#000000">
<pre class="SCREEN">
<tt class="PROMPT">bash$ </tt>
<tt class="USERINPUT">
<b>diff3 file-1 file-2 file-3</b>
</tt>
<tt class="COMPUTEROUTPUT">====
 1:1c
   This is line 1 of "file-1".
 2:1c
   This is line 1 of "file-2".
 3:1c
   This is line 1 of "file-3"</tt>
	      </pre>
</font>
</td>
</tr>
</tbody>
</table>
	      </p>
<p>
<a name="MERGEREF">
</a>The <b class="COMMAND">merge</b>
	      (3-way file merge) command is an interesting adjunct to
	      <i class="FIRSTTERM">diff3</i>. Its syntax is
	      <tt class="USERINPUT">
<b>merge Mergefile file1 file2</b>
</tt>.
	      The result is to output to <tt class="FILENAME">Mergefile</tt>
	      the changes that lead from <tt class="FILENAME">file1</tt>
	      to <tt class="FILENAME">file2</tt>. Consider this command
	      a stripped-down version of <i class="FIRSTTERM">patch</i>.</p>
</dd>
<dt>
<a name="SDIFFREF">
</a>
<b class="COMMAND">sdiff</b>
</dt>
<dd>
<p>Compare and/or edit two files in order to merge
	      them into an output file. Because of its interactive nature,
	      this command would find little use in a script.</p>
</dd>
<dt>
<a name="CMPREF">
</a>
<b class="COMMAND">cmp</b>
</dt>
<dd>
<p>
<b class="COMMAND">cmp</b> 명령어는, 위의 
<b class="COMMAND">diff</b> 의 간단한 버전입니다. 
<b class="COMMAND">diff</b> 가 두 파일간의 차이를 알려주는 반면, 
<b class="COMMAND">cmp</b> 는 단순히 어디가 다른 지만 보여줍니다.</p>
<div class="NOTE">
<p>
</p>
<table class="NOTE" border="0" width="90%">
<tbody>
<tr>
<td align="CENTER" valign="TOP" width="25">
<img src="filearchiv_files/note.gif" alt="Note" hspace="5">
</td>
<td align="LEFT" valign="TOP">
<p>
<b class="COMMAND">diff</b> 처럼, 
<b class="COMMAND">cmp</b> 는 두 파일이 같다면 0 을 반환합니다. 그리고 만일 
다르다면 1 을 반환합니다. 쉘 스크립트에서는 이 방법으로 비교 구문을 사용할 수 
있습니다.</p>
</td>
</tr>
</tbody>
</table>
</div>
<div class="EXAMPLE">
<a name="FILECOMP">
</a>
<p>
<b>예 16-35. 스크립트에서 <i class="FIRSTTERM">cmp</i> 을 이용해서 두개의 파일을 비교하기</b>
</p>
<table bgcolor="#E0E0E0" border="0" width="90%">
<tbody>
<tr>
<td>
<font color="#000000">
<pre class="PROGRAMLISTING">#!/bin/bash
# file-comparison.sh

ARGS=2  # Two args to script expected.
E_BADARGS=85
E_UNREADABLE=86

if [ $# -ne "$ARGS" ]
then
  echo "Usage: `basename $0` file1 file2"
  exit $E_BADARGS
fi

if [[ ! -r "$1" || ! -r "$2" ]]
then
  echo "Both files to be compared must exist and be readable."
  exit $E_UNREADABLE
fi

cmp $1 $2 &amp;&gt; /dev/null
#   Redirection to /dev/null buries the output of the "cmp" command.
#   cmp -s $1 $2  has same result ("-s" silent flag to "cmp")
#   Thank you  Anders Gustavsson for pointing this out.
#
#  Also works with 'diff', i.e.,
#+ diff $1 $2 &amp;&gt; /dev/null

if [ $? -eq 0 ]         # Test exit status of "cmp" command.
then
  echo "File \"$1\" is identical to file \"$2\"."
else  
  echo "File \"$1\" differs from file \"$2\"."
fi

exit 0</pre>
</font>
</td>
</tr>
</tbody>
</table>
</div>
<div class="TIP">
<p>
</p>
<table class="TIP" border="0" width="90%">
<tbody>
<tr>
<td align="CENTER" valign="TOP" width="25">
<img src="filearchiv_files/tip.gif" alt="Tip" hspace="5">
</td>
<td align="LEFT" valign="TOP">
<p>
<i class="FIRSTTERM">gzipped</i> 된 파일은 
<b class="COMMAND">zcmp</b> 을 사용하십시요.</p>
</td>
</tr>
</tbody>
</table>
</div>
</dd>
<dt>
<a name="COMMREF">
</a>
<b class="COMMAND">comm</b>
</dt>
<dd>
<p>다목적 파일 비교 유틸리티. 제대로 된 결과를 얻으려면 파일 내용이 정렬되어 
있어야 합니다.</p>
<p>
<b class="COMMAND">comm
<tt class="REPLACEABLE">
<i>-options</i>
</tt>
<tt class="REPLACEABLE">
<i>first-file</i>
</tt>
<tt class="REPLACEABLE">
<i>second-file</i>
</tt>
</b>
</p>
<p>
<tt class="USERINPUT">
<b>comm file-1 file-2</b>
</tt> 은 3개의 열을 출력합니다:
</p>
<p>
</p>
<ul>
<li>
<p>column 1 = <tt class="FILENAME">file-1</tt> 에서 유일한 줄
</p>
</li>
<li>
<p>column 2 = <tt class="FILENAME">file-2</tt> 에서 유일한 줄
</p>
</li>
<li>
<p>column 3 = 두 파일에서 공통의 줄</p>
</li>
</ul>
<p>
</p>
<p>다음 옵션은 하나 이상의 출력 칸을 제거해 줍니다.
</p>
<p>
</p>
<ul>
<li>
<p>
<tt class="OPTION">-1</tt> 은 
<tt class="LITERAL">1</tt> 번 칸을 제거
</p>
</li>
<li>
<p>
<tt class="OPTION">-2</tt> 는 
<tt class="LITERAL">2</tt> 번 칸을 제거
</p>
</li>
<li>
<p>
<tt class="OPTION">-3</tt> 은 
<tt class="LITERAL">3</tt> 번 칸을 제거
</p>
</li>
<li>
<p>
<tt class="OPTION">-12</tt> 는 
<tt class="LITERAL">1</tt> 번과 
<tt class="LITERAL">2</tt> 번 칸을 제거, 등등.</p>
</li>
</ul>
<p>
</p>
<p>이 명령어는 
<span class="QUOTE">"사전 형식"</span> 이나 
<i class="FIRSTTERM">단어 리스트</i> -- 한 줄에 한 단어씩 정렬되어 있는 텍스트 
파일들 -- 을 비교할 때 유용합니다.</p>
</dd>
</dl>
</div>
<p>
</p>
<div class="VARIABLELIST">
<p>
<b>
<a name="FAUTILS1">
</a>Utilities</b>
</p>
<dl>
<dt>
<a name="BASENAMEREF">
</a>
<b class="COMMAND">basename</b>
</dt>
<dd>
<p>파일명에서 경로 정보를 잘라내, 파일명만 프린트합니다. 스크립트에서 
<tt class="USERINPUT"><b>basename $0</b></tt> 는 스크립트 자신의 파일명을 알 수 
있게 해줍니다. 예를 들어 스크립트를 실행하기 위해 필요한 인수 중 빠진 인수를 
알려 주기 위한 <span class="QUOTE">"알림"</span> 메세지에서 이 명령어를 쓸 수도 있습니다:
<table bgcolor="#E0E0E0" border="0" width="90%">
<tbody>
<tr>
<td>
<font color="#000000">
<pre class="PROGRAMLISTING">echo "Usage: `basename $0` arg1 arg2 ... argn"</pre>
</font>
</td>
</tr>
</tbody>
</table>
</p>
</dd>
<dt>
<a name="DIRNAMEREF">
</a>
<b class="COMMAND">dirname</b>
</dt>
<dd>
<p>Strips the <b class="COMMAND">basename</b> from
	    a filename, printing only the path information.</p>
<div class="NOTE">
<p>
</p>
<table class="NOTE" border="0" width="90%">
<tbody>
<tr>
<td align="CENTER" valign="TOP" width="25">
<img src="filearchiv_files/note.gif" alt="Note" hspace="5">
</td>
<td align="LEFT" valign="TOP">
<p>
<b class="COMMAND">basename</b> and <b class="COMMAND">dirname</b>
		can operate on any arbitrary string. The argument
		does not need to refer to an existing file, or
		even be a filename for that matter (see <a href="./contributed-scripts.html#DAYSBETWEEN">Example A-7</a>).</p>
</td>
</tr>
</tbody>
</table>
</div>
<div class="EXAMPLE">
<a name="EX35">
</a>
<p>
<b>Example 16-36. <i class="FIRSTTERM">basename</i> and
	      <i class="FIRSTTERM">dirname</i>
</b>
</p>
<table bgcolor="#E0E0E0" border="0" width="90%">
<tbody>
<tr>
<td>
<font color="#000000">
<pre class="PROGRAMLISTING">#!/bin/bash

address=/home/bozo/daily-journal.txt

echo "Basename of /home/bozo/daily-journal.txt = `basename $address`"
echo "Dirname of /home/bozo/daily-journal.txt = `dirname $address`"
echo
echo "My own home is `basename ~/`."         # `basename ~` also works.
echo "The home of my home is `dirname ~/`."  # `dirname ~`  also works.

exit 0</pre>
</font>
</td>
</tr>
</tbody>
</table>
</div>
</dd>
<dt>
<a name="SPLITREF">
</a>
<b class="COMMAND">split</b>, <a name="CSPLITREF">
</a>
<b class="COMMAND">csplit</b>
</dt>
<dd>
<p>These are utilities for splitting a file into smaller
	      chunks. Their usual use is for splitting up large files
	      in order to back them up on floppies or preparatory to
	      e-mailing or uploading them.</p>
<p>The <b class="COMMAND">csplit</b> command splits a file
	      according to <i class="FIRSTTERM">context</i>, the split occuring
	      where patterns are matched.</p>
<div class="EXAMPLE">
<a name="SPLITCOPY">
</a>
<p>
<b>Example 16-37. A script that copies itself in sections</b>
</p>
<table bgcolor="#E0E0E0" border="0" width="90%">
<tbody>
<tr>
<td>
<font color="#000000">
<pre class="PROGRAMLISTING">#!/bin/bash
# splitcopy.sh

#  A script that splits itself into chunks,
#+ then reassembles the chunks into an exact copy
#+ of the original script.

CHUNKSIZE=4    #  Size of first chunk of split files.
OUTPREFIX=xx   #  csplit prefixes, by default,
               #+ files with "xx" ...

csplit "$0" "$CHUNKSIZE"

# Some comment lines for padding . . .
# Line 15
# Line 16
# Line 17
# Line 18
# Line 19
# Line 20

cat "$OUTPREFIX"* &gt; "$0.copy"  # Concatenate the chunks.
rm "$OUTPREFIX"*               # Get rid of the chunks.

exit $?</pre>
</font>
</td>
</tr>
</tbody>
</table>
</div>
</dd>
</dl>
</div>
<p>
</p>
<div class="VARIABLELIST">
<p>
<b>
<a name="FAENCENCR1">
</a>Encoding and Encryption</b>
</p>
<dl>
<dt>
<a name="SUMREF">
</a>
<b class="COMMAND">sum</b>, <a name="CKSUMREF">
</a>
<b class="COMMAND">cksum</b>, <a name="MD5SUMREF">
</a>
<b class="COMMAND">md5sum</b>, <a name="SHA1SUMREF">
</a>
<b class="COMMAND">sha1sum</b>
</dt>
<dd>
<p>
<a name="CHECKSUMREF">
</a>이 유틸리티들은 <i class="FIRSTTERM">Checksums</i> 을 만들어 줍니다. 
<i class="FIRSTTERM">Checksum</i> 은 파일의 내용을 수학적으로 계산한 숫자
<a name="AEN12840" href="#FTN.AEN12840">
<span class="footnote">[3]
</span>
</a> 이며, 이를 이용해서 파일의 무결성을 확인할 수 있습니다. 중요한 시스템 파일의 
내용이 변경 혹은 손상되었는 지 확인하기 위한 보안 목적을 위해 Checksum 의 목록을 
만들어 이를 참조하는 스크립트를 만들어 쓸 수도 있습니다. 보안 어플리케이션을 위해선 
<b class="COMMAND">md5sum</b> (
<b class="COMMAND">m</b>essage 
<b class="COMMAND">d</b>igest 
<b class="COMMAND">5</b> check
<b class="COMMAND">sum</b>) 명령어나, 새로운 
<b class="COMMAND">sha1sum</b> (Secure Hash Algorithm) 을 사용하는 것이 좋습니다. 
<a name="AEN12849" href="#FTN.AEN12849">
<span class="footnote">[4]</span>
</a>
</p>
<p>
<table bgcolor="#E0E0E0" border="1" width="90%">
<tbody>
<tr>
<td>
<font color="#000000">
<pre class="SCREEN">
<tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>cksum /boot/vmlinuz</b></tt>
<tt class="COMPUTEROUTPUT">1670054224 804083 /boot/vmlinuz</tt>

<tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>echo -n "Top Secret" | cksum</b></tt>
<tt class="COMPUTEROUTPUT">3391003827 10</tt>



<tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>md5sum /boot/vmlinuz</b></tt>
<tt class="COMPUTEROUTPUT">0f43eccea8f09e0a0b2b5cf1dcf333ba  /boot/vmlinuz</tt>

<tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>echo -n "Top Secret" | md5sum</b></tt>
<tt class="COMPUTEROUTPUT">8babc97a6f62a4649716f4df8d61728f  -</tt>

</pre>
</font>
</td>
</tr>
</tbody>
</table>
	  </p>
<div class="NOTE">
<p>
</p>
<table class="NOTE" border="0" width="90%">
<tbody>
<tr>
<td align="CENTER" valign="TOP" width="25">
<img src="filearchiv_files/note.gif" alt="Note" hspace="5">
</td>
<td align="LEFT" valign="TOP">
<p>
<b class="COMMAND">cksum</b> 명령어는 파일이건
<tt class="FILENAME">stdout</tt> 이건, 크기, 바이트, 타겟을 보여줍니다.
</p>
<p>
<b class="COMMAND">md5sum</b> 과 
<b class="COMMAND">sha1sum</b> 명령어는 
<tt class="FILENAME">stdout</tt> 에서 입력을 받게 되면, 
<a href="./special-chars.html#DASHREF2">dash</a> 로 출력하게 됩니다.
</p>
</td>
</tr>
</tbody>
</table>
</div>
<div class="EXAMPLE">
<a name="FILEINTEGRITY">
</a>
<p>
<b>Example 16-38. Checking file integrity</b>
</p>
<table bgcolor="#E0E0E0" border="0" width="90%">
<tbody>
<tr>
<td>
<font color="#000000">
<pre class="PROGRAMLISTING">#!/bin/bash
# file-integrity.sh: Checking whether files in a given directory
#                    have been tampered with.

E_DIR_NOMATCH=80
E_BAD_DBFILE=81

dbfile=File_record.md5
# Filename for storing records (database file).


set_up_database ()
{
  echo ""$directory"" &gt; "$dbfile"
  # Write directory name to first line of file.
  md5sum "$directory"/* &gt;&gt; "$dbfile"
  # Append md5 checksums and filenames.
}

check_database ()
{
  local n=0
  local filename
  local checksum

  # ------------------------------------------- #
  #  This file check should be unnecessary,
  #+ but better safe than sorry.

  if [ ! -r "$dbfile" ]
  then
    echo "Unable to read checksum database file!"
    exit $E_BAD_DBFILE
  fi
  # ------------------------------------------- #

  while read record[n]
  do

    directory_checked="${record[0]}"
    if [ "$directory_checked" != "$directory" ]
    then
      echo "Directories do not match up!"
      # Tried to use file for a different directory.
      exit $E_DIR_NOMATCH
    fi

    if [ "$n" -gt 0 ]   # Not directory name.
    then
      filename[n]=$( echo ${record[$n]} | awk '{ print $2 }' )
      #  md5sum writes records backwards,
      #+ checksum first, then filename.
      checksum[n]=$( md5sum "${filename[n]}" )


      if [ "${record[n]}" = "${checksum[n]}" ]
      then
        echo "${filename[n]} unchanged."

        elif [ "`basename ${filename[n]}`" != "$dbfile" ]
               #  Skip over checksum database file,
               #+ as it will change with each invocation of script.
               #  ---
               #  This unfortunately means that when running
               #+ this script on $PWD, tampering with the
               #+ checksum database file will not be detected.
               #  Exercise: Fix this.
        then
          echo "${filename[n]} : CHECKSUM ERROR!"
        # File has been changed since last checked.
        fi

      fi



    let "n+=1"
  done &lt;"$dbfile"       # Read from checksum database file. 

}  

# =================================================== #
# main ()

if [ -z  "$1" ]
then
  directory="$PWD"      #  If not specified,
else                    #+ use current working directory.
  directory="$1"
fi  

clear                   # Clear screen.
echo " Running file integrity check on $directory"
echo

# ------------------------------------------------------------------ #
  if [ ! -r "$dbfile" ] # Need to create database file?
  then
    echo "Setting up database file, \""$directory"/"$dbfile"\"."; echo
    set_up_database
  fi  
# ------------------------------------------------------------------ #

check_database          # Do the actual work.

echo 

#  You may wish to redirect the stdout of this script to a file,
#+ especially if the directory checked has many files in it.

exit 0

#  For a much more thorough file integrity check,
#+ consider the "Tripwire" package,
#+ http://sourceforge.net/projects/tripwire/.</pre>
</font>
</td>
</tr>
</tbody>
</table>
</div>
<p>
<a href="./contributed-scripts.html#DIRECTORYINFO">예 A-19</a>, 
<a href="./colorizing.html#HORSERACE">예 36-16</a>, 그리고 
<a href="./string-manipulation.html#RANDSTRING">예 10-2</a> 에 있는 
<b class="COMMAND">md5sum</b> 명령어의 독창적인 사용법을 참고하십시요.
</p>
<div class="NOTE">
<p>
</p>
<table class="NOTE" border="0" width="90%">
<tbody>
<tr>
<td align="CENTER" valign="TOP" width="25">
<img src="filearchiv_files/note.gif" alt="Note" hspace="5">
</td>
<td align="LEFT" valign="TOP">
<p>128-bit 
<b class="COMMAND">md5sum</b> 이 크랙될 수 있다는 보고가 있었습니다, 그래서 160-bit 
<b class="COMMAND">sha1sum</b> 이 새로운 Checksum 툴로 각광받고 있습니다.</p>
<table bgcolor="#E0E0E0" border="1" width="90%">
<tbody>
<tr>
<td>
<font color="#000000">
<pre class="SCREEN">
<tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>md5sum testfile</b></tt>
<tt class="COMPUTEROUTPUT">e181e2c8720c60522c4c4c981108e367  testfile</tt>


<tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>sha1sum testfile</b></tt>
<tt class="COMPUTEROUTPUT">5d7425a9c08a66c3177f1e31286fa40986ffc996  testfile</tt>

</pre>
</font>
</td>
</tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
</div>
<p>보안 전문가들은 
<b class="COMMAND">sha1sum</b> 가 안전하지 못할 수 있다는 것 입증했습니다. 
운 좋게도, 새로운 리눅스 배포판에는 더 긴 비트 길이를 가진 
<b class="COMMAND">sha224sum</b>, 
<b class="COMMAND">sha256sum</b>, 
<b class="COMMAND">sha384sum</b>, 그리고 
<b class="COMMAND">sha512sum</b> 명령어가 포함될 것입니다.</p>
</dd>
<dt>
<a name="UUENCODEREF">
</a>
<b class="COMMAND">uuencode</b>
</dt>
<dd>
<p>This utility encodes binary files (images, sound files,
		    compressed files, etc.) into <a href="./special-chars.html#ASCIIDEF">ASCII</a> characters, making
		    them suitable for transmission in the body of an
		    e-mail message or in a newsgroup posting. This is
		    especially useful where MIME (multimedia) encoding
		    is not available.</p>
</dd>
<dt>
<a name="UUDECODEREF">
</a>
<b class="COMMAND">uudecode</b>
</dt>
<dd>
<p>This reverses the encoding, decoding
	      <i class="FIRSTTERM">uuencoded</i> files back into the
	      original binaries.</p>
<div class="EXAMPLE">
<a name="EX52">
</a>
<p>
<b>Example 16-39. Uudecoding encoded files</b>
</p>
<table bgcolor="#E0E0E0" border="0" width="90%">
<tbody>
<tr>
<td>
<font color="#000000">
<pre class="PROGRAMLISTING">#!/bin/bash
# Uudecodes all uuencoded files in current working directory.

lines=35        # Allow 35 lines for the header (very generous).

for File in *   # Test all the files in $PWD.
do
  search1=`head -n $lines $File | grep begin | wc -w`
  search2=`tail -n $lines $File | grep end | wc -w`
  #  Uuencoded files have a "begin" near the beginning,
  #+ and an "end" near the end.
  if [ "$search1" -gt 0 ]
  then
    if [ "$search2" -gt 0 ]
    then
      echo "uudecoding - $File -"
      uudecode $File
    fi  
  fi
done  

#  Note that running this script upon itself fools it
#+ into thinking it is a uuencoded file,
#+ because it contains both "begin" and "end".

#  Exercise:
#  --------
#  Modify this script to check each file for a newsgroup header,
#+ and skip to next if not found.

exit 0</pre>
</font>
</td>
</tr>
</tbody>
</table>
</div>
<div class="TIP">
<p>
</p>
<table class="TIP" border="0" width="90%">
<tbody>
<tr>
<td align="CENTER" valign="TOP" width="25">
<img src="filearchiv_files/tip.gif" alt="Tip" hspace="5">
</td>
<td align="LEFT" valign="TOP">
<p>The <a href="./textproc.html#FOLDREF">fold -s</a> command
	    may be useful (possibly in a pipe) to process long uudecoded
	    text messages downloaded from Usenet newsgroups.</p>
</td>
</tr>
</tbody>
</table>
</div>
</dd>
<dt>
<a name="MIMENCODEREF">
</a>
<b class="COMMAND">mimencode</b>, <a name="MMENCODEREF">
</a>
<b class="COMMAND">mmencode</b>
</dt>
<dd>
<p>The <b class="COMMAND">mimencode</b> and
	      <b class="COMMAND">mmencode</b> commands process
	      multimedia-encoded e-mail attachments. Although
	      <i class="FIRSTTERM">mail user agents</i> (such as
	      <i class="FIRSTTERM">pine</i> or <i class="FIRSTTERM">kmail</i>)
	      normally handle this automatically, these particular
	      utilities permit manipulating such attachments manually from
	      the command-line or in <a href="./timedate.html#BATCHPROCREF">batch
	      processing mode</a> by means of a shell script.</p>
</dd>
<dt>
<a name="CRYPTREF">
</a>
<b class="COMMAND">crypt</b>
</dt>
<dd>
<p>At one time, this was the standard UNIX file encryption
	      utility.

              <a name="AEN12969" href="#FTN.AEN12969">
<span class="footnote">[5]</span>
</a>

	      Politically-motivated government regulations
	      prohibiting the export of encryption software resulted
	      in the disappearance of <b class="COMMAND">crypt</b>
	      from much of the UNIX world, and it is still
	      missing from most Linux distributions. Fortunately,
	      programmers have come up with a number of decent
	      alternatives to it, among them the author's very own <a href="ftp://metalab.unc.edu/pub/Linux/utils/file/cruft-0.2.tar.gz" target="_top">cruft</a>
	      (see <a href="./contributed-scripts.html#ENCRYPTEDPW">Example A-4</a>).  </p>
</dd>
<dt>
<a name="OPENSSLREF">
</a>
<b class="COMMAND">openssl</b>
</dt>
<dd>
<p>This is an Open Source implementation of
             <i class="FIRSTTERM">Secure Sockets Layer</i> encryption.

	     <table bgcolor="#E0E0E0" border="0" width="90%">
<tbody>
<tr>
<td>
<font color="#000000">
<pre class="PROGRAMLISTING"># To encrypt a file:
openssl aes-128-ecb -salt -in file.txt -out file.encrypted \
-pass pass:my_password
#          ^^^^^^^^^^^   User-selected password.
#       aes-128-ecb      is the encryption method chosen.

# To decrypt an openssl-encrypted file:
openssl aes-128-ecb -d -salt -in file.encrypted -out file.txt \
-pass pass:my_password
#          ^^^^^^^^^^^   User-selected password.</pre>
</font>
</td>
</tr>
</tbody>
</table>
</p>
<p>
<a href="./special-chars.html#PIPEREF">Piping</a>
             <i class="FIRSTTERM">openssl</i> to/from <a href="./filearchiv.html#TARREF">tar</a> makes it possible to encrypt
             an entire directory tree.
     
            <table bgcolor="#E0E0E0" border="0" width="90%">
<tbody>
<tr>
<td>
<font color="#000000">
<pre class="PROGRAMLISTING"># To encrypt a directory:

sourcedir="/home/bozo/testfiles"
encrfile="encr-dir.tar.gz"
password=my_secret_password

tar czvf - "$sourcedir" |
openssl des3 -salt -out "$encrfile" -pass pass:"$password"
#       ^^^^   Uses des3 encryption.
# Writes encrypted file "encr-dir.tar.gz" in current working directory.

# To decrypt the resulting tarball:
openssl des3 -d -salt -in "$encrfile" -pass pass:"$password" |
tar -xzv
# Decrypts and unpacks into current working directory.</pre>
</font>
</td>
</tr>
</tbody>
</table>

           </p>
<p>Of course, <i class="FIRSTTERM">openssl</i> has many other uses,
             such as obtaining signed <i class="FIRSTTERM">certificates</i>
	     for Web sites. See the <a href="./basic.html#INFOREF">info</a>
	     page.</p>
</dd>
<dt>
<a name="SHREDREF">
</a>
<b class="COMMAND">shred</b>
</dt>
<dd>
<p>Securely erase a file by overwriting it multiple times with
	      random bit patterns before deleting it. This command has
	      the same effect as <a href="./extmisc.html#BLOTOUT">Example 16-61</a>, but does it
	      in a more thorough and elegant manner.</p>
<p>This is one of the GNU
	    <i class="FIRSTTERM">fileutils</i>.</p>
<div class="CAUTION">
<p>
</p>
<table class="CAUTION" border="0" width="90%">
<tbody>
<tr>
<td align="CENTER" valign="TOP" width="25">
<img src="filearchiv_files/caution.gif" alt="Caution" hspace="5">
</td>
<td align="LEFT" valign="TOP">
<p>Advanced forensic technology may still be able to
	      recover the contents of a file, even after application of
	      <b class="COMMAND">shred</b>.</p>
</td>
</tr>
</tbody>
</table>
</div>
</dd>
</dl>
</div>
<p>
</p>
<div class="VARIABLELIST">
<p>
<b>
<a name="FAMISC1">
</a>Miscellaneous</b>
</p>
<dl>
<dt>
<a name="MKTEMPREF">
</a>
<b class="COMMAND">mktemp</b>
</dt>
<dd>
<p>Create a <i class="FIRSTTERM">temporary file</i>

	       <a name="AEN13030" href="#FTN.AEN13030">
<span class="footnote">[6]</span>
</a>

	      with a <span class="QUOTE">"unique"</span> filename. When invoked
	      from the command-line without additional arguments,
	      it creates a zero-length file in the <tt class="FILENAME">/tmp</tt> directory.</p>
<p>	      <table bgcolor="#E0E0E0" border="1" width="90%">
<tbody>
<tr>
<td>
<font color="#000000">
<pre class="SCREEN">
<tt class="PROMPT">bash$ </tt>
<tt class="USERINPUT">
<b>mktemp</b>
</tt>
<tt class="COMPUTEROUTPUT">/tmp/tmp.zzsvql3154</tt>
	      </pre>
</font>
</td>
</tr>
</tbody>
</table>
	    </p>
<p>
<table bgcolor="#E0E0E0" border="0" width="90%">
<tbody>
<tr>
<td>
<font color="#000000">
<pre class="PROGRAMLISTING">PREFIX=filename
tempfile=`mktemp $PREFIX.XXXXXX`
#                        ^^^^^^ Need at least 6 placeholders
#+                              in the filename template.
#   If no filename template supplied,
#+ "tmp.XXXXXXXXXX" is the default.

echo "tempfile name = $tempfile"
# tempfile name = filename.QA2ZpY
#                 or something similar...

#  Creates a file of that name in the current working directory
#+ with 600 file permissions.
#  A "umask 177" is therefore unnecessary,
#+ but it's good programming practice nevertheless.</pre>
</font>
</td>
</tr>
</tbody>
</table>
</p>
</dd>
<dt>
<a name="MAKEREF">
</a>
<b class="COMMAND">make</b>
</dt>
<dd>
<p>
<a name="MAKEFILEREF">
</a>
</p>
<p>Utility for building and compiling binary packages. 
	      This can also be used for any set of operations triggered
	      by incremental changes in source files.</p>
<p>The <i class="FIRSTTERM">make</i> command checks a
	    <tt class="FILENAME">Makefile</tt>, a list of file dependencies and
	      operations to be carried out.</p>
<p>The <i class="FIRSTTERM">make</i> utility is, in effect,
	      a powerful scripting language similar in many ways to
	      <i class="FIRSTTERM">Bash</i>, but with the capability of
	      recognizing <i class="FIRSTTERM">dependencies</i>. For in-depth
	      coverage of this useful tool set, see the <a href="http://www.gnu.org/manual/manual.html" target="_top">GNU software
	      documentation site</a>.</p>
</dd>
<dt>
<a name="INSTALLREF">
</a>
<b class="COMMAND">install</b>
</dt>
<dd>
<p>Special purpose file copying command, similar to
	      <a href="./basic.html#CPREF">cp</a>, but capable of
	      setting permissions and attributes of the copied
	      files. This command seems tailormade for installing
	      software packages, and as such it shows up frequently in
	      <tt class="FILENAME">Makefiles</tt> (in the <tt class="REPLACEABLE">
<i>make
	      install :</i>
</tt> section). It could likewise prove
	      useful in installation scripts.</p>
</dd>
<dt>
<a name="DOS2UNIXREF">
</a>
<b class="COMMAND">dos2unix</b>
</dt>
<dd>
<p>This utility, written by Benjamin Lin and collaborators,
	      converts DOS-formatted text files (lines terminated by
	      CR-LF) to UNIX format (lines terminated by LF only),
	      and <a href="./gotchas.html#DOSNEWLINES">vice-versa</a>.</p>
</dd>
<dt>
<a name="PTXREF">
</a>
<b class="COMMAND">ptx</b>
</dt>
<dd>
<p>The <b class="COMMAND">ptx [targetfile]</b> command
	      outputs a permuted index (cross-reference list) of the
	      targetfile. This may be further filtered and formatted in a
	      pipe, if necessary.</p>
</dd>
<dt>
<a name="MOREREF">
</a>
<b class="COMMAND">more</b>, <a name="LESSREF">
</a>
<b class="COMMAND">less</b>
</dt>
<dd>
<p>Pagers that display a text file or stream to
	      <tt class="FILENAME">stdout</tt>, one screenful at a time.
	      These may be used to filter the output of
	      <tt class="FILENAME">stdout</tt> . . . or of a script.</p>
<p>	       An interesting application of <i class="FIRSTTERM">more</i>
	       is to <span class="QUOTE">"test drive"</span> a command sequence,
	       to forestall potentially unpleasant consequences.
                 <table bgcolor="#E0E0E0" border="0" width="90%">
<tbody>
<tr>
<td>
<font color="#000000">
<pre class="PROGRAMLISTING">ls /home/bozo | awk '{print "rm -rf " $1}' | more
#                                            ^^^^
		 
# Testing the effect of the following (disastrous) command-line:
#      ls /home/bozo | awk '{print "rm -rf " $1}' | sh
#      Hand off to the shell to execute . . .       ^^</pre>
</font>
</td>
</tr>
</tbody>
</table>
            </p>
<p>The <i class="FIRSTTERM">less</i> pager has the
	      interesting property of doing a formatted display of
	      <i class="FIRSTTERM">man page</i> source. See <a href="./contributed-scripts.html#MANED">Example A-39</a>.</p>
</dd>
</dl>
</div>
</div>
<h3 class="FOOTNOTES">Notes</h3>
<table class="FOOTNOTES" border="0" width="100%">
<tbody>
<tr>
<td align="LEFT" valign="TOP" width="5%">
<a name="FTN.AEN11885" href="./filearchiv.html#AEN11885">
<span class="footnote">[1]</span>
</a>
</td>
<td align="LEFT" valign="TOP" width="95%">
<p>An <i class="FIRSTTERM">archive</i>,
	        in the sense discussed here, is simply a set of related
	        files stored in a single location.</p>
</td>
</tr>
<tr>
<td align="LEFT" valign="TOP" width="5%">
<a name="FTN.AEN11896" href="./filearchiv.html#AEN11896">
<span class="footnote">[2]</span>
</a>
</td>
<td align="LEFT" valign="TOP" width="95%">
<p>		    A <tt class="REPLACEABLE">
<i>tar czvf ArchiveName.tar.gz *</i>
</tt>
		    <em>will</em> include dotfiles in
		    subdirectories <em>below</em> the current
		    working directory. This is an undocumented GNU
		    <b class="COMMAND">tar</b> <span class="QUOTE">"feature."</span>
		  </p>
</td>
</tr>
<tr>
<td align="LEFT" valign="TOP" width="5%">
<a name="FTN.AEN12840" href="./filearchiv.html#AEN12840">
<span class="footnote">[3]</span>
</a>
</td>
<td align="LEFT" valign="TOP" width="95%">
<p>The checksum may be expressed as a
		<i class="FIRSTTERM">hexadecimal</i> number, or to some
		other base.</p>
</td>
</tr>
<tr>
<td align="LEFT" valign="TOP" width="5%">
<a name="FTN.AEN12849" href="./filearchiv.html#AEN12849">
<span class="footnote">[4]</span>
</a>
</td>
<td align="LEFT" valign="TOP" width="95%">
<p>For even <em>better</em>
		  security, use the <i class="FIRSTTERM">sha256sum</i>,
		  <i class="FIRSTTERM">sha512</i>, and
                  <i class="FIRSTTERM">sha1pass</i>
                  commands.</p>
</td>
</tr>
<tr>
<td align="LEFT" valign="TOP" width="5%">
<a name="FTN.AEN12969" href="./filearchiv.html#AEN12969">
<span class="footnote">[5]</span>
</a>
</td>
<td align="LEFT" valign="TOP" width="95%">
<p>This is a symmetric block cipher, used to
		encrypt files on a single system or local network,
		as opposed to the <i class="FIRSTTERM">public key</i>
		cipher class, of which <i class="FIRSTTERM">pgp</i> is a
		well-known example.</p>
</td>
</tr>
<tr>
<td align="LEFT" valign="TOP" width="5%">
<a name="FTN.AEN13030" href="./filearchiv.html#AEN13030">
<span class="footnote">[6]</span>
</a>
</td>
<td align="LEFT" valign="TOP" width="95%">
<p>Creates a temporary
	       <i class="FIRSTTERM">directory</i> when invoked with the
	       <tt class="OPTION">-d</tt> option.</p>
</td>
</tr>
</tbody>
</table>
<div class="NAVFOOTER">
<hr align="LEFT" width="100%">
<table summary="Footer navigation table" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody>
<tr>
<td align="left" valign="top" width="33%">
<a href="./textproc.html" accesskey="P">Prev</a>
</td>
<td align="center" valign="top" width="34%">
<a href="./index.html" accesskey="H">Home</a>
</td>
<td align="right" valign="top" width="33%">
<a href="./communications.html" accesskey="N">Next</a>
</td>
</tr>
<tr>
<td align="left" valign="top" width="33%">Text Processing Commands</td>
<td align="center" valign="top" width="34%">
<a href="./external.html" accesskey="U">Up</a>
</td>
<td align="right" valign="top" width="33%">Communications Commands</td>
</tr>
</tbody>
</table>
</div>
</body>
</html>
